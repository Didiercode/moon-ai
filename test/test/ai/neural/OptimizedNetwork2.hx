package test.ai.neural;

import haxe.ds.Vector;
import moon.ai.neural.Network.INetwork;

class OptimizedNetwork2 implements INetwork
{
    public var f:Vector<Float>;

    public function new()
    {
        f = new Vector<Float>(61);
        f[57] = 0.999911569868754;
        f[5] = 0;
        f[8] = 0;
        f[33] = 1;
        f[38] = 0;
        f[44] = 4.12492098018575;
        f[16] = 3.33715665354954;
        f[7] = 0;
        f[12] = 0.129027753594074;
        f[3] = 0;
        f[40] = 0.00058018287552835;
        f[25] = 0;
        f[31] = 5.54199161485333;
        f[46] = 1;
        f[48] = 0.00649988614217044;
        f[60] = 0;
        f[6] = 1;
        f[58] = 0.847810647344105;
        f[42] = 7.45100582459464;
        f[11] = 0.847810647344105;
        f[17] = 3.30186099415361;
        f[29] = 9.33320936115326;
        f[14] = 1.7175318309202;
        f[20] = -0.0741757287195624;
        f[41] = 3.32608484440889;
        f[39] = 0.999419480121142;
        f[55] = -2.31925031983034;
        f[9] = 0;
        f[4] = 0;
        f[49] = 2.91825407335185;
        f[47] = 1;
        f[0] = 0;
        f[28] = 3.79121774629993;
        f[36] = 5.69948261696839;
        f[2] = 0;
        f[53] = 0.0815235382935235;
        f[59] = 0.999419480121142;
        f[19] = 1;
        f[27] = 8.84223113581521e-005;
        f[34] = 1;
        f[13] = -1.58432916323341;
        f[45] = 4.34114623373555;
        f[18] = 1;
        f[43] = -1.01506138932666;
        f[50] = 0.00649988614217044;
        f[30] = -1.99642510244936;
        f[1] = 1;
        f[15] = -4.92148581678295;
        f[52] = 0.0895411571101477;
        f[23] = 0.0663584139089424;
        f[54] = 2.71625645212739;
        f[26] = 0.999911569868754;
        f[22] = -7.76285324201104;
        f[32] = 5.7876428487493;
        f[35] = 0.00818844790698311;
        f[51] = 0;
        f[56] = -4.35335926730692;
        f[37] = 0.00818844790698311;
        f[10] = 0;
        f[24] = -0.0741757287195624;
        f[21] = 0;
    }
    
    public function activate(input:Array<Float>):Array<Float>
    {
        f[1] = input[0];
        f[6] = input[1];
        f[13] = f[14];
        f[14] = f[15];
        f[14] += f[1] * f[16];
        f[14] += f[6] * f[17];
        f[11] = (1.0 / (1.0 + Math.exp(-f[14])));
        f[12] = f[11] * (1.0 - f[11]);
        f[18] = f[1];
        f[19] = f[6];
        f[28] = f[29];
        f[29] = f[30];
        f[29] += f[6] * f[31];
        f[29] += f[1] * f[32];
        f[26] = (1.0 / (1.0 + Math.exp(-f[29])));
        f[27] = f[26] * (1.0 - f[26]);
        f[33] = f[6];
        f[34] = f[1];
        f[41] = f[42];
        f[42] = f[43];
        f[42] += f[6] * f[44];
        f[42] += f[1] * f[45];
        f[39] = (1.0 / (1.0 + Math.exp(-f[42])));
        f[40] = f[39] * (1.0 - f[39]);
        f[46] = f[6];
        f[47] = f[1];
        f[54] = f[55];
        f[55] = f[56];
        f[55] += f[26] * f[36];
        f[55] += f[11] * f[22];
        f[55] += f[39] * f[49];
        f[52] = (1.0 / (1.0 + Math.exp(-f[55])));
        f[53] = f[52] * (1.0 - f[52]);
        f[57] = f[26];
        f[58] = f[11];
        f[59] = f[39];
        
        var output:Array<Float> = [];
        output[0] = f[52];
        return output;
    }
    
    public function propagate(rate:Float=0.1, target:Array<Float>):Void
    {
        f[0] = rate;
        f[60] = target[0];
        f[23] = f[60] - f[52];
        f[36] += f[0] * (f[23] * f[57]);
        f[22] += f[0] * (f[23] * f[58]);
        f[49] += f[0] * (f[23] * f[59]);
        f[56] += f[0] * f[23];
        f[21] += f[23] * f[49];
        f[50] = f[40] * f[21];
        f[21] = 0;
        f[51] = f[40] * f[21];
        f[48] = f[50] + f[51];
        f[21] = f[50] * f[46];
        f[44] += f[0] * f[21];
        f[21] = f[50] * f[47];
        f[45] += f[0] * f[21];
        f[43] += f[0] * f[48];
        f[21] += f[23] * f[36];
        f[37] = f[27] * f[21];
        f[21] = 0;
        f[38] = f[27] * f[21];
        f[35] = f[37] + f[38];
        f[21] = f[37] * f[33];
        f[31] += f[0] * f[21];
        f[21] = f[37] * f[34];
        f[32] += f[0] * f[21];
        f[30] += f[0] * f[35];
        f[21] += f[23] * f[22];
        f[24] = f[12] * f[21];
        f[21] = 0;
        f[25] = f[12] * f[21];
        f[20] = f[24] + f[25];
        f[21] = f[24] * f[18];
        f[16] += f[0] * f[21];
        f[21] = f[24] * f[19];
        f[17] += f[0] * f[21];
        f[15] += f[0] * f[20];
    }
    
    public function ownership(memory:Vector<Float>):Void
    {
        f = memory;
    }
}
