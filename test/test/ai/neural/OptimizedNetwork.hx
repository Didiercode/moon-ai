package test.ai.neural;

import haxe.ds.Vector;
import moon.ai.neural.Network.INetwork;

class OptimizedNetwork implements INetwork
{
    public var f:Vector<Float>;

    public function new()
    {
        f = new Vector<Float>(61);
        f[57] = 0.721558272908958;
        f[5] = 0;
        f[8] = 0;
        f[33] = 1;
        f[38] = 0;
        f[44] = 2.72701966077565;
        f[16] = 6.44500532489949;
        f[7] = 0;
        f[12] = 3.4513095667819e-005;
        f[3] = 0;
        f[40] = 0.166493759994511;
        f[25] = 0;
        f[31] = 1.72425906231586;
        f[46] = 1;
        f[48] = -0.0638810591695954;
        f[60] = 0;
        f[6] = 1;
        f[58] = 0.999965485713096;
        f[42] = 1.31875479673814;
        f[11] = 0.999965485713096;
        f[17] = 6.417775830717;
        f[29] = 0.952204342263438;
        f[14] = 10.2741026916128;
        f[20] = 0.0111272348656467;
        f[41] = -1.40826486403751;
        f[39] = 0.788974462549009;
        f[55] = -2.44460426098831;
        f[9] = 0;
        f[4] = 0;
        f[49] = -6.00438984492199;
        f[47] = 1;
        f[0] = 0;
        f[28] = -0.772054720052425;
        f[36] = -4.38648537210524;
        f[2] = 0;
        f[53] = 0.0734605539685921;
        f[59] = 0.788974462549009;
        f[19] = 1;
        f[27] = 0.2009119317056;
        f[34] = 1;
        f[13] = 3.85632686089577;
        f[45] = 2.66707979459444;
        f[18] = 1;
        f[43] = -4.07534465863194;
        f[50] = -0.0638810591695954;
        f[30] = -2.58891904023555;
        f[1] = 1;
        f[15] = -2.58867846400372;
        f[52] = 0.0798340256143914;
        f[23] = 0.0663515039133676;
        f[54] = 2.72138465253882;
        f[26] = 0.721558272908958;
        f[22] = 8.23456137598165;
        f[32] = 1.81686432018312;
        f[35] = -0.0634941806326171;
        f[51] = 0;
        f[56] = -2.77646636688738;
        f[37] = -0.0634941806326171;
        f[10] = 0;
        f[24] = 0.0111272348656467;
        f[21] = 0;
    }
    
    public function activate(input:Array<Float>):Array<Float>
    {
        f[1] = input[0];
        f[6] = input[1];
        f[13] = f[14];
        f[14] = f[15];
        f[14] += f[1] * f[16];
        f[14] += f[6] * f[17];
        f[11] = (1.0 / (1.0 + Math.exp(-f[14])));
        f[12] = f[11] * (1.0 - f[11]);
        f[18] = f[1];
        f[19] = f[6];
        f[28] = f[29];
        f[29] = f[30];
        f[29] += f[6] * f[31];
        f[29] += f[1] * f[32];
        f[26] = (1.0 / (1.0 + Math.exp(-f[29])));
        f[27] = f[26] * (1.0 - f[26]);
        f[33] = f[6];
        f[34] = f[1];
        f[41] = f[42];
        f[42] = f[43];
        f[42] += f[6] * f[44];
        f[42] += f[1] * f[45];
        f[39] = (1.0 / (1.0 + Math.exp(-f[42])));
        f[40] = f[39] * (1.0 - f[39]);
        f[46] = f[6];
        f[47] = f[1];
        f[54] = f[55];
        f[55] = f[56];
        f[55] += f[26] * f[36];
        f[55] += f[11] * f[22];
        f[55] += f[39] * f[49];
        f[52] = (1.0 / (1.0 + Math.exp(-f[55])));
        f[53] = f[52] * (1.0 - f[52]);
        f[57] = f[26];
        f[58] = f[11];
        f[59] = f[39];
        
        var output:Array<Float> = [];
        output[0] = f[52];
        return output;
    }
    
    public function propagate(rate:Float=0.1, target:Array<Float>):Void
    {
        f[0] = rate;
        f[60] = target[0];
        f[23] = f[60] - f[52];
        f[36] += f[0] * (f[23] * f[57]);
        f[22] += f[0] * (f[23] * f[58]);
        f[49] += f[0] * (f[23] * f[59]);
        f[56] += f[0] * f[23];
        f[21] += f[23] * f[49];
        f[50] = f[40] * f[21];
        f[21] = 0;
        f[51] = f[40] * f[21];
        f[48] = f[50] + f[51];
        f[21] = f[50] * f[46];
        f[44] += f[0] * f[21];
        f[21] = f[50] * f[47];
        f[45] += f[0] * f[21];
        f[43] += f[0] * f[48];
        f[21] += f[23] * f[36];
        f[37] = f[27] * f[21];
        f[21] = 0;
        f[38] = f[27] * f[21];
        f[35] = f[37] + f[38];
        f[21] = f[37] * f[33];
        f[31] += f[0] * f[21];
        f[21] = f[37] * f[34];
        f[32] += f[0] * f[21];
        f[30] += f[0] * f[35];
        f[21] += f[23] * f[22];
        f[24] = f[12] * f[21];
        f[21] = 0;
        f[25] = f[12] * f[21];
        f[20] = f[24] + f[25];
        f[21] = f[24] * f[18];
        f[16] += f[0] * f[21];
        f[21] = f[24] * f[19];
        f[17] += f[0] * f[21];
        f[15] += f[0] * f[20];
    }
    
    public function ownership(memory:Vector<Float>):Void
    {
        f = memory;
    }
}
