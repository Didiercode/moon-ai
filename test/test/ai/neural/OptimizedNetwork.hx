package test.ai.neural;

import haxe.ds.Vector;
import moon.ai.neural.Network.INetwork;

class OptimizedNetwork implements INetwork
{
    public var f:Vector<Float>;

    public function new()
    {
        f = new Vector<Float>(61);
        f[57] = 0.76093995398174;
        f[5] = 0;
        f[8] = 0;
        f[33] = 1;
        f[38] = 0;
        f[44] = 4.03766503469299;
        f[16] = 7.71475624845253;
        f[7] = 0;
        f[12] = 8.16378411705974e-006;
        f[3] = 0;
        f[40] = 0.128047403507619;
        f[25] = 0;
        f[31] = 2.7894226974708;
        f[46] = 1;
        f[48] = 0.000136177039424567;
        f[60] = 0;
        f[6] = 1;
        f[58] = 0.999991836149234;
        f[42] = 1.72847396392893;
        f[11] = 0.999991836149234;
        f[17] = 7.57354960240954;
        f[29] = 1.1578396917045;
        f[14] = 11.7157864288783;
        f[20] = -0.00244075203190026;
        f[41] = -2.30919107076405;
        f[39] = 0.849217119414815;
        f[55] = -5.5038201444873;
        f[9] = 0;
        f[4] = 0;
        f[49] = -9.2210853933499;
        f[47] = 1;
        f[0] = 0;
        f[28] = -1.6315830057663;
        f[36] = -6.93584591446449;
        f[2] = 0;
        f[53] = 0.00403824134236114;
        f[59] = 0.849217119414815;
        f[19] = 1;
        f[27] = 0.181910340416007;
        f[34] = 1;
        f[13] = 4.14223682646873;
        f[45] = 3.87239717315702;
        f[18] = 1;
        f[43] = -6.18158824392107;
        f[50] = 0.000136177039424567;
        f[30] = -4.60282689391307;
        f[1] = 1;
        f[15] = -3.5725194219838;
        f[52] = 0.00405468178675296;
        f[23] = -0.00717392663409309;
        f[54] = 5.43654234855977;
        f[26] = 0.76093995398174;
        f[22] = 12.798227784225;
        f[32] = 2.97124388814677;
        f[35] = 0.000488843117934817;
        f[51] = 0;
        f[56] = -5.19347759929495;
        f[37] = 0.000488843117934817;
        f[10] = 0;
        f[24] = -0.00244075203190026;
        f[21] = 0;
    }
    
    public function activate(input:Array<Float>):Array<Float>
    {
        f[1] = input[0];
        f[6] = input[1];
        f[13] = f[14];
        f[14] = f[15];
        f[14] += f[1] * f[16];
        f[14] += f[6] * f[17];
        f[11] = (1.0 / (1.0 + Math.exp(-f[14])));
        f[12] = f[11] * (1.0 - f[11]);
        f[18] = f[1];
        f[19] = f[6];
        f[28] = f[29];
        f[29] = f[30];
        f[29] += f[6] * f[31];
        f[29] += f[1] * f[32];
        f[26] = (1.0 / (1.0 + Math.exp(-f[29])));
        f[27] = f[26] * (1.0 - f[26]);
        f[33] = f[6];
        f[34] = f[1];
        f[41] = f[42];
        f[42] = f[43];
        f[42] += f[6] * f[44];
        f[42] += f[1] * f[45];
        f[39] = (1.0 / (1.0 + Math.exp(-f[42])));
        f[40] = f[39] * (1.0 - f[39]);
        f[46] = f[6];
        f[47] = f[1];
        f[54] = f[55];
        f[55] = f[56];
        f[55] += f[26] * f[36];
        f[55] += f[11] * f[22];
        f[55] += f[39] * f[49];
        f[52] = (1.0 / (1.0 + Math.exp(-f[55])));
        f[53] = f[52] * (1.0 - f[52]);
        f[57] = f[26];
        f[58] = f[11];
        f[59] = f[39];
        
        var output:Array<Float> = [];
        output[0] = f[52];
        return output;
    }
    
    public function propagate(rate:Float=0.1, target:Array<Float>):Void
    {
        f[0] = rate;
        f[60] = target[0];
        f[23] = f[60] - f[52];
        f[36] += f[0] * (f[23] * f[57]);
        f[22] += f[0] * (f[23] * f[58]);
        f[49] += f[0] * (f[23] * f[59]);
        f[56] += f[0] * f[23];
        f[21] += f[23] * f[49];
        f[50] = f[40] * f[21];
        f[21] = 0;
        f[51] = f[40] * f[21];
        f[48] = f[50] + f[51];
        f[21] = f[50] * f[46];
        f[44] += f[0] * f[21];
        f[21] = f[50] * f[47];
        f[45] += f[0] * f[21];
        f[43] += f[0] * f[48];
        f[21] += f[23] * f[36];
        f[37] = f[27] * f[21];
        f[21] = 0;
        f[38] = f[27] * f[21];
        f[35] = f[37] + f[38];
        f[21] = f[37] * f[33];
        f[31] += f[0] * f[21];
        f[21] = f[37] * f[34];
        f[32] += f[0] * f[21];
        f[30] += f[0] * f[35];
        f[21] += f[23] * f[22];
        f[24] = f[12] * f[21];
        f[21] = 0;
        f[25] = f[12] * f[21];
        f[20] = f[24] + f[25];
        f[21] = f[24] * f[18];
        f[16] += f[0] * f[21];
        f[21] = f[24] * f[19];
        f[17] += f[0] * f[21];
        f[15] += f[0] * f[20];
    }
    
    public function ownership(memory:Vector<Float>):Void
    {
        f = memory;
    }
}
