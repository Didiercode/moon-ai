package moon.ai.neural.generated;

import haxe.ds.Vector;

class Test
{
    public var f:Vector<Float>;

    public function new()
    {
        f = new Vector<Float>(61);
        f[57] = 0.783207939608824;
        f[5] = 0;
        f[8] = 0;
        f[33] = 1;
        f[38] = 0;
        f[44] = 2.28040868239188;
        f[16] = 6.45822269765546;
        f[7] = 0;
        f[12] = 3.40802936420968e-005;
        f[3] = 0;
        f[40] = 0.190259181912123;
        f[25] = 0;
        f[31] = 2.24421987139586;
        f[46] = 1;
        f[48] = 0.0180378610503855;
        f[60] = 0;
        f[6] = 1;
        f[58] = 0.999965918544812;
        f[42] = 1.06906649701565;
        f[11] = 0.999965918544812;
        f[17] = 6.47260219089519;
        f[29] = 1.2844595814783;
        f[14] = 10.2867230757086;
        f[20] = -0.0371697196571454;
        f[41] = -1.21134218537624;
        f[39] = 0.744419348841038;
        f[55] = -2.45505986082046;
        f[9] = 0;
        f[4] = 0;
        f[49] = -4.80436167362163;
        f[47] = 1;
        f[0] = 0;
        f[28] = -0.959760289917565;
        f[36] = -5.8317560143479;
        f[2] = 0;
        f[53] = 0.0728173608272979;
        f[59] = 0.744419348841038;
        f[19] = 1;
        f[27] = 0.169793262942524;
        f[34] = 1;
        f[13] = 3.81412088481338;
        f[45] = 1.60272139837172;
        f[18] = 1;
        f[43] = -2.81406358374796;
        f[50] = 0.0180378610503855;
        f[30] = -3.79520577963278;
        f[1] = 1;
        f[15] = -2.64410181284208;
        f[52] = 0.0790693178530435;
        f[23] = -0.0705750286174149;
        f[54] = 2.7894814480496;
        f[26] = 0.783207939608824;
        f[22] = 8.4468249451344;
        f[32] = 2.83544548971521;
        f[35] = 0.00883429040113103;
        f[51] = 0;
        f[56] = -2.75765952489597;
        f[37] = 0.00883429040113103;
        f[10] = 0;
        f[24] = -0.0371697196571454;
        f[21] = 0;
    }
    
    public function activate(input:Array<Float>):Array<Float>
    {
        f[1] = input[0];
        f[6] = input[1];
        f[13] = f[14];
        f[14] = f[15];
        f[14] += f[1] * f[16];
        f[14] += f[6] * f[17];
        f[11] = (1 / (1 + Math.exp(-f[14])));
        f[12] = f[11] * (1 - f[11]);
        f[18] = f[1];
        f[19] = f[6];
        f[28] = f[29];
        f[29] = f[30];
        f[29] += f[6] * f[31];
        f[29] += f[1] * f[32];
        f[26] = (1 / (1 + Math.exp(-f[29])));
        f[27] = f[26] * (1 - f[26]);
        f[33] = f[6];
        f[34] = f[1];
        f[41] = f[42];
        f[42] = f[43];
        f[42] += f[6] * f[44];
        f[42] += f[1] * f[45];
        f[39] = (1 / (1 + Math.exp(-f[42])));
        f[40] = f[39] * (1 - f[39]);
        f[46] = f[6];
        f[47] = f[1];
        f[54] = f[55];
        f[55] = f[56];
        f[55] += f[26] * f[36];
        f[55] += f[11] * f[22];
        f[55] += f[39] * f[49];
        f[52] = (1 / (1 + Math.exp(-f[55])));
        f[53] = f[52] * (1 - f[52]);
        f[57] = f[26];
        f[58] = f[11];
        f[59] = f[39];
        
        var output:Array<Float> = [];
        output[0] = f[52];
        return output;
    }
    
    public function propagate(rate:Float, target:Array<Float>):Void
    {
        f[0] = rate;
        f[60] = target[0];
        f[23] = f[60] - f[52];
        f[36] += f[0] * (f[23] * f[57]);
        f[22] += f[0] * (f[23] * f[58]);
        f[49] += f[0] * (f[23] * f[59]);
        f[56] += f[0] * f[23];
        f[21] += f[23] * f[49];
        f[50] = f[40] * f[21];
        f[21] = 0;
        f[51] = f[40] * f[21];
        f[48] = f[50] + f[51];
        f[21] = f[50] * f[46];
        f[44] += f[0] * f[21];
        f[21] = f[50] * f[47];
        f[45] += f[0] * f[21];
        f[43] += f[0] * f[48];
        f[21] += f[23] * f[36];
        f[37] = f[27] * f[21];
        f[21] = 0;
        f[38] = f[27] * f[21];
        f[35] = f[37] + f[38];
        f[21] = f[37] * f[33];
        f[31] += f[0] * f[21];
        f[21] = f[37] * f[34];
        f[32] += f[0] * f[21];
        f[30] += f[0] * f[35];
        f[21] += f[23] * f[22];
        f[24] = f[12] * f[21];
        f[21] = 0;
        f[25] = f[12] * f[21];
        f[20] = f[24] + f[25];
        f[21] = f[24] * f[18];
        f[16] += f[0] * f[21];
        f[21] = f[24] * f[19];
        f[17] += f[0] * f[21];
        f[15] += f[0] * f[20];
    }
    
    public function ownership(memory:Vector<Float>):Void
    {
        f = memory;
    }
}
