package moon.ai.neural.generated;

import haxe.ds.Vector;
import moon.ai.neural.Network.INetwork;

class Blah implements INetwork
{
    public var f:Vector<Float>;

    public function new()
    {
        f = new Vector<Float>(61);
        f[57] = 0.999942020420047;
        f[5] = 0;
        f[8] = 0;
        f[33] = 1;
        f[38] = 0;
        f[44] = 3.04039755495408;
        f[16] = 3.36630448515278;
        f[7] = 0;
        f[12] = 0.132545296333291;
        f[3] = 0;
        f[40] = 0.0017238324195063;
        f[25] = 0;
        f[31] = 5.98286695167637;
        f[46] = 1;
        f[48] = -0.0170730156002506;
        f[60] = 0;
        f[6] = 1;
        f[58] = 0.842716652158469;
        f[42] = 6.35974870198888;
        f[11] = 0.842716652158469;
        f[17] = 3.35669717901088;
        f[29] = 9.75536169792694;
        f[14] = 1.67858184102375;
        f[20] = 0.00292951116123275;
        f[41] = 3.3193511470348;
        f[39] = 0.998273185692842;
        f[55] = -2.38883496309447;
        f[9] = 0;
        f[4] = 0;
        f[49] = 1.15397306295462;
        f[47] = 1;
        f[0] = 0;
        f[28] = 3.77249474625057;
        f[36] = 6.93607599243551;
        f[2] = 0;
        f[53] = 0.0769673436753723;
        f[59] = 0.998273185692842;
        f[19] = 1;
        f[27] = 5.79762183212133e-005;
        f[34] = 1;
        f[13] = -1.67811533798713;
        f[45] = 3.11596266497218;
        f[18] = 1;
        f[43] = 0.203388482062617;
        f[50] = -0.0170730156002506;
        f[30] = -2.3128999028169;
        f[1] = 1;
        f[15] = -5.04441982313991;
        f[52] = 0.0840280582483625;
        f[23] = -0.0598149481094094;
        f[54] = 2.69581573566361;
        f[26] = 0.999942020420047;
        f[22] = -7.70159330022506;
        f[32] = 6.08539464906747;
        f[35] = -0.0341902570734384;
        f[51] = 0;
        f[56] = -3.98622824826509;
        f[37] = -0.0341902570734384;
        f[10] = 0;
        f[24] = 0.00292951116123275;
        f[21] = 0;
    }
    
    public function activate(input:Array<Float>):Array<Float>
    {
        f[1] = input[0];
        f[6] = input[1];
        f[13] = f[14];
        f[14] = f[15];
        f[14] += f[1] * f[16];
        f[14] += f[6] * f[17];
        f[11] = (1.0 / (1.0 + Math.exp(-f[14])));
        f[12] = f[11] * (1.0 - f[11]);
        f[18] = f[1];
        f[19] = f[6];
        f[28] = f[29];
        f[29] = f[30];
        f[29] += f[6] * f[31];
        f[29] += f[1] * f[32];
        f[26] = (1.0 / (1.0 + Math.exp(-f[29])));
        f[27] = f[26] * (1.0 - f[26]);
        f[33] = f[6];
        f[34] = f[1];
        f[41] = f[42];
        f[42] = f[43];
        f[42] += f[6] * f[44];
        f[42] += f[1] * f[45];
        f[39] = (1.0 / (1.0 + Math.exp(-f[42])));
        f[40] = f[39] * (1.0 - f[39]);
        f[46] = f[6];
        f[47] = f[1];
        f[54] = f[55];
        f[55] = f[56];
        f[55] += f[26] * f[36];
        f[55] += f[11] * f[22];
        f[55] += f[39] * f[49];
        f[52] = (1.0 / (1.0 + Math.exp(-f[55])));
        f[53] = f[52] * (1.0 - f[52]);
        f[57] = f[26];
        f[58] = f[11];
        f[59] = f[39];
        
        var output:Array<Float> = [];
        output[0] = f[52];
        return output;
    }
    
    public function propagate(rate:Float=0.1, target:Array<Float>):Void
    {
        f[0] = rate;
        f[60] = target[0];
        f[23] = f[60] - f[52];
        f[36] += f[0] * (f[23] * f[57]);
        f[22] += f[0] * (f[23] * f[58]);
        f[49] += f[0] * (f[23] * f[59]);
        f[56] += f[0] * f[23];
        f[21] += f[23] * f[49];
        f[50] = f[40] * f[21];
        f[21] = 0;
        f[51] = f[40] * f[21];
        f[48] = f[50] + f[51];
        f[21] = f[50] * f[46];
        f[44] += f[0] * f[21];
        f[21] = f[50] * f[47];
        f[45] += f[0] * f[21];
        f[43] += f[0] * f[48];
        f[21] += f[23] * f[36];
        f[37] = f[27] * f[21];
        f[21] = 0;
        f[38] = f[27] * f[21];
        f[35] = f[37] + f[38];
        f[21] = f[37] * f[33];
        f[31] += f[0] * f[21];
        f[21] = f[37] * f[34];
        f[32] += f[0] * f[21];
        f[30] += f[0] * f[35];
        f[21] += f[23] * f[22];
        f[24] = f[12] * f[21];
        f[21] = 0;
        f[25] = f[12] * f[21];
        f[20] = f[24] + f[25];
        f[21] = f[24] * f[18];
        f[16] += f[0] * f[21];
        f[21] = f[24] * f[19];
        f[17] += f[0] * f[21];
        f[15] += f[0] * f[20];
    }
    
    public function ownership(memory:Vector<Float>):Void
    {
        f = memory;
    }
}
